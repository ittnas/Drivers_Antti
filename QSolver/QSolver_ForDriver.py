# -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 2018

@author: Fei Yan
"""

import numpy as np
from scipy.linalg import eig
from qutip import *

import logging
log = logging.getLogger('LabberDriver')

# import scipy.constants as const
# #Constants.
# h = const.h #planck constant
# h_bar = const.hbar #h_bar
# e = const.e #electron charge
# phi0= h/(2*e) #flux quantum
# RQ = h/(2*e)**2 #quantum resistance



def Ej_SQUID(flux,Ej_sum,d):
	# effective Ej of a SQUID
	return Ej_sum * np.abs(np.cos(np.pi*flux)) * np.sqrt(1+d**2*np.tan(np.pi*flux)**2) #[GHz]

def freq_SQUID(Ej, Ec):
	return np.sqrt(8 * Ej *Ec) - Ec

def freq_LC(L,C):
	# frequency of LC oscillator
	# L [nH]
	# C [fH]
	return 1/(2*np.pi)/np.sqrt(L*C)/1e-3   #[GHz]

def Z_LC(L,C):
	# impedence of LC oscillator
	return np.sqrt(L/C)*1e3   #[Ohm]

def U(H,t):
	# unitary propagator generated by H over time t 
	H = Qobj(H)
	return Qobj(-1j * H * t).expm()

def T(A, U, *args, **kwargs):
	A = Qobj(A)
	U = Qobj(U)
	return U * A * U.dag()

def Qflatten(Q):
	return Qobj(Q.full())

def eigensolve(H):
	# find eigensolution of H
	H = H.full()
	vals, vecs = eig(H)    
	#idx = vals.argsort()[::-1] #Descending Order
	idx = vals.argsort() #Ascending Order
	vals = vals[idx]
	vecs = vecs[:,idx]
	return np.real(vals), vecs

def level_identify(vals, vecs, list_table, list_select):
	# identify and sort eigen solutions according to "list_select"
	v_idx = []
	for k, str_level in enumerate(list_select):
		idx_sort = np.argsort(np.abs(vecs[list_table.index(str_level),:]))
		count = 1
		while True:
			if idx_sort[-count] in v_idx:
				count += 1
			else:
				v_idx.append(idx_sort[-count])
				break			
	return vals[v_idx], vecs[:,v_idx]



class MultiQubitHamiltonian():

	def __init__(self):
		# init with some default settings
		self.nQubit = 3
		self.nTrunc = 4
		# self.nShow = 4
		self.bDesignParam_Q1 = False
		self.bDesignParam_Q2 = False
		self.bDesignParam_Q3 = False
		self.sQubitType_Q1 = '2-JJ'
		self.sQubitType_Q2 = '2-JJ'
		self.sQubitType_Q3 = '2-JJ'
		# frequencies [GHz]
		self.dFreq_Q1 = 4.0
		self.dFreq_Q2 = 4.0
		self.dFreq_Q3 = 4.0
		self.dAnh_Q1 = -0.3
		self.dAnh_Q2 = -0.3
		self.dAnh_Q3 = -0.3
		# capacitances [fF]
		self.dC1 = 80.0
		self.dC2 = 80.0
		self.dC3 = 80.0
		self.dC12 = 1.0
		self.dC23 = 1.0
		self.dC13 = 0.02
		# inductances [nH]
		#
		# designer parameter set
		# josephson energy [GHz]
		self.dEj_Q1 = 10.0
		self.dEj_Q2 = 10.0
		self.dEj_Q3 = 10.0
		# charging energy [GHz]
		self.dEc_Q1 = 0.2
		self.dEc_Q2 = 0.2
		self.dEc_Q3 = 0.2
		# SQUID asymmetry |A1-A2|/(A1+A2)
		self.dAsym_Q1 = 0.0
		self.dAsym_Q2 = 0.0
		self.dAsym_Q3 = 0.0
		# flux bias [Phi0]
		self.dFlux_Q1 = 0.0
		self.dFlux_Q2 = 0.0
		self.dFlux_Q3 = 0.0
		# #
		# # calculate partial coupling coefficients (approximate)
		# self.c12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
		# self.c23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
		# self.c13 = self.dC13 / np.sqrt(self.dC1 * self.dC3)
		# #
		# if simCfg is not None:
		# 	# update simulation options
		# 	self.updateSimCfg(simCfg)


	def updateSimCfg(self, simCfg):
		# update simulation options
		for key, value in simCfg.items():
			if hasattr(self, key):
				setattr(self, key, value)
		# update capacitance coupling coefficient
		self.c12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
		self.c23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
		self.c13 = self.dC13 / np.sqrt(self.dC1 * self.dC3)
		# update frequencies if using designer parameter set
		if self.bDesignParam_Q1:
			if self.sQubitType_Q1 == '2-JJ':
				setattr(self, 'dFreq_Q1', freq_SQUID(Ej_SQUID(self.dFlux_Q1,self.dEj_Q1,self.dAsym_Q1), self.dEc_Q1))
				setattr(self, 'dAnh_Q1', -self.dEc_Q1)
		if self.bDesignParam_Q2:
			if self.sQubitType_Q2 == '2-JJ':
				setattr(self, 'dFreq_Q2', freq_SQUID(Ej_SQUID(self.dFlux_Q2,self.dEj_Q2,self.dAsym_Q2), self.dEc_Q2))
				setattr(self, 'dAnh_Q2', -self.dEc_Q2)
		if self.bDesignParam_Q3:
			if self.sQubitType_Q3 == '2-JJ':
				setattr(self, 'dFreq_Q3', freq_SQUID(Ej_SQUID(self.dFlux_Q3,self.dEj_Q3,self.dAsym_Q3), self.dEc_Q3))
				setattr(self, 'dAnh_Q3', -self.dEc_Q3)


	def generateOperators(self):
		# generate basic operators. matrix truncated at nTrunc 
		I = qeye(self.nTrunc)
		a = destroy(self.nTrunc)
		x = a + a.dag()
		p = -1j*(a - a.dag())
		aa = a.dag() * a
		aaaa = a.dag() * a.dag() * a * a
		return {'I':I, 'a':a, 'x':x, 'p':p, 'aa':aa, 'aaaa':aaaa}


	def generateSubHamiltonian_1Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p']))


	def generateHamiltonian_1Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_1Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_12


	def generateLabel_1Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			self.list_label_table.append(list_label_gen[k1])


	def generateSubHamiltonian_2Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x']))#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p']))


	def generateHamiltonian_2Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_2Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_12


	def generateLabel_2Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2])


	def generateSubHamiltonian_3Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa'], OP['I']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa'], OP['I']))
		self.H_Q3_aa = Qflatten(tensor(OP['I'], OP['I'], OP['aa']))
		self.H_Q3_aaaa = Qflatten(tensor(OP['I'], OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x'], OP['I']))
		self.H_23_xx = Qflatten(tensor(OP['I'], OP['x'], OP['x']))
		self.H_13_xx = Qflatten(tensor(OP['x'], OP['I'], OP['x']))		#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p'], OP['I']))
		self.H_23_pp = Qflatten(tensor(OP['I'], OP['p'], OP['p']))
		self.H_13_pp = Qflatten(tensor(OP['p'], OP['I'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x'], OP['I']))
		self.H_dr_Q3_x = Qflatten(tensor(OP['I'], OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p'], OP['I']))
		self.H_dr_Q3_p = Qflatten(tensor(OP['I'], OP['I'], OP['p']))


	def generateHamiltonian_3Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_3Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		self.H_Q3 = self.dFreq_Q3 * self.H_Q3_aa + self.dAnh_Q3/2 * self.H_Q3_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		self.g_23 = 0.5 * self.c23 * np.sqrt(self.dFreq_Q2 * self.dFreq_Q3)
		self.H_23 = self.g_23 * self.H_23_pp
		self.g_13 = 0.5 * (self.c12 * self.c23 + self.c13) * np.sqrt(self.dFreq_Q1 * self.dFreq_Q3)
		self.H_13 = self.g_13 * self.H_13_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_Q3 + self.H_12 + self.H_23 + self.H_13


	def generateLabel_3Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				for k3 in np.arange(self.nTrunc):
					self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2] + list_label_gen[k3])

